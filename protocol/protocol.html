<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CHAMP Protocol – Prototype</title>
  <style>
    * {
      box-sizing: border-box;
    }

    :root {
      --red: #d33131;
      --blue: #1975d2;
      --neutral-1: #f5f5f5;
      --neutral-2: #9e9e9e;
      --neutral-3: #616161;
      --border: #c9c9c9;
      --text: #1f1f1f;
    }

    html,
    body {
      margin: 0;
      min-width: 320px;
      min-height: 320px;
      height: 100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: var(--neutral-1);
    }

    body {
      padding: 0.5rem;
    }

    .app {
      height: calc(100vh - 1rem);
      min-height: 304px;
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 8px;
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      gap: 0.5rem;
      padding: 0.5rem;
      overflow: hidden;
    }

    .top-bar {
      display: grid;
      grid-template-columns: minmax(120px, 1fr) auto auto auto;
      gap: 0.5rem;
      align-items: center;
    }

    .field,
    .select,
    .action {
      min-height: 2.25rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      padding: 0 0.6rem;
      font-size: 0.92rem;
    }

    .action {
      font-weight: 600;
      cursor: pointer;
    }

    /* Mirror the pencil glyph for the blue side's header action button */
    .side.blue .side-head .action {
      display: inline-block;
      transform: scaleX(-1);
      line-height: 1;
    }

    .board {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      min-height: 0;
    }

    .buttons {
      display: grid;
      grid-template-columns: 1fr minmax(130px, 180px) 1fr;
      gap: 0.5rem;
      min-height: 0;
    }

    .side {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      gap: 0.45rem;
      min-height: 0;
    }

    .button-side {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 0.45rem;
      min-height: 0;
    }

    .side.red {
      background: color-mix(in srgb, var(--red) 8%, white);
    }

    .side.blue {
      background: color-mix(in srgb, var(--blue) 8%, white);
    }

    .button-side.red {
      background: color-mix(in srgb, var(--red) 8%, white);
    }

    .button-side.blue {
      background: color-mix(in srgb, var(--blue) 8%, white);
    }

    .side-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
    }

    .score {
      font-size: clamp(2rem, 5vw, 3.4rem);
      font-variant-numeric: tabular-nums;
      line-height: 1;
      font-weight: 700;
      text-align: center;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      padding: 0.2rem 0;
    }

    .injury-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.4rem;
    }

    .mini-time {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      padding: 0.35rem;
      text-align: center;
      font-size: 0.82rem;
      font-variant-numeric: tabular-nums;
    }

    .event-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.35rem;
      align-content: start;
    }

    .event-btn {
      border: 1px solid transparent;
      border-radius: 6px;
      min-height: 3rem;
      font-weight: 700;
      font-size: 0.9rem;
      cursor: default;
      color: #fff;
    }

    .red .event-btn {
      background: var(--red);
      border-color: var(--red);
    }

    .blue .event-btn {
      background: var(--blue);
      border-color: var(--blue);
    }

    .center {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      gap: 0.5rem;
      align-content: start;
    }

    .mode-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.35rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--neutral-1);
      padding: 0.25rem 0.35rem;
    }

    .mode-chip {
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      padding: 0.16rem 0.45rem;
      border: 1px solid var(--neutral-3);
      color: var(--neutral-3);
      background: #fff;
    }

    .mode-chip.active {
      background: var(--neutral-3);
      color: #fff;
    }

    .mode-hint {
      font-size: 0.72rem;
      color: var(--neutral-3);
      font-weight: 600;
    }

    .time-label {
      text-align: center;
      color: var(--neutral-3);
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .bout-time {
      border: 2px solid var(--neutral-3);
      border-radius: 10px;
      background: #fff;
      padding: 0.6rem 0.3rem;
      cursor: pointer;
      text-align: center;
    }

    .time {
      font-size: clamp(2.2rem, 6vw, 3rem);
      font-variant-numeric: tabular-nums;
      font-weight: 700;
      line-height: 1;
    }

    .time-note {
      margin-top: 0.2rem;
      font-size: 0.72rem;
      color: var(--neutral-3);
    }

    .timeline {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.4rem;
      display: flex;
      gap: 0.4rem;
      overflow-x: auto;
      align-items: flex-start;
    }

    .entry {
      min-width: 50px;
      display: grid;
      gap: 0.15rem;
      justify-items: center;
    }

    .entry-box {
      width: 50px;
      height: 40px;
      border-radius: 4px;
      border: 2px solid;
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #fff;
      font-size: 0.92rem;
    }

    .entry-box.caution {
      display: grid;
      grid-template-rows: 1fr 1fr;
      padding: 0;
      overflow: hidden;
      background: #fff;
    }

    .entry-box.caution.blue {
      border-color: var(--blue);
    }

    .entry-box.caution.red {
      border-color: var(--red);
    }

    .caution-row {
      width: 100%;
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 0.82rem;
      line-height: 1;
      color: #fff;
    }

    .caution-row.blue {
      background: var(--blue);
    }

    .caution-row.red {
      background: var(--red);
    }

    .entry-box.red {
      background: var(--red);
      border-color: var(--red);
    }

    .entry-box.blue {
      background: var(--blue);
      border-color: var(--blue);
    }

    .entry-box.next {
      background: var(--neutral-1);
      border-color: var(--neutral-3);
      border-style: dashed;
      color: var(--neutral-3);
    }

    .entry-box.cursor {
      border-color: var(--neutral-3);
      box-shadow: 0 0 0 2px #fff, 0 0 0 4px var(--neutral-3);
    }

    .entry-time {
      font-size: 0.72rem;
      color: var(--neutral-3);
      font-variant-numeric: tabular-nums;
    }

    .correction-bar {
      display: flex;
      gap: 0.3rem;
      align-items: center;
      flex-wrap: wrap;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.35rem;
      background: #fff;
    }

    .correction-action {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--neutral-1);
      color: var(--neutral-3);
      font-size: 0.76rem;
      font-weight: 700;
      padding: 0.24rem 0.5rem;
      white-space: nowrap;
    }

    .correction-action.primary {
      background: var(--neutral-3);
      border-color: var(--neutral-3);
      color: #fff;
    }

    @media (max-width: 850px) {
      .board,
      .buttons {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        overflow: auto;
      }

      .buttons .center {
        order: -1;
      }
    }

    @media (max-height: 420px) {
      .event-btn {
        min-height: 1.6rem;
      }

      .score {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>
  <main id="app" class="app" aria-label="CHAMP Protocol Prototype">
    <section id="top-bar" class="top-bar" aria-label="Scoresheet Header">
      <input id="bout-info" class="field" type="text" value="Wettkampf: Landesmeisterschaft; U17 74kg" aria-label="Bout Info" />
      <select id="style-select" class="select" aria-label="Style">
        <option selected>Freestyle</option>
        <option>Greco-Roman</option>
      </select>
      <select id="ruleset-select" class="select" aria-label="Ruleset">
        <option selected>Default Ruleset</option>
      </select>
    </section>

    <section id="board" class="board" aria-label="Bout Area">
      <article id="side-red" class="side red" aria-label="Wrestler Red">
        <header id="info-red" class="side-head"><button class="action" type="button" aria-label="Bearbeiten">✎</button><span>Rot</span></header>
        <div id="score-red" class="score" aria-label="Score Red">0</div>
      </article>

      <article id="side-blue" class="side blue" aria-label="Wrestler Blue">
        <header id="info-blue" class="side-head"><span>Blau</span><button class="action" type="button" aria-label="Bearbeiten">✎</button></header>
        <div id="score-blue" class="score" aria-label="Score Blue">0</div>
      </article>
    </section>

    <section id="timeline" class="timeline" aria-label="Timeline">
      <div class="entry">
        <div class="entry-box red">1R</div>
        <div class="entry-time">0:12</div>
      </div>
      <div class="entry">
        <div class="entry-box blue cursor">PB</div>
        <div class="entry-time">0:39</div>
      </div>
      <div class="entry">
        <div class="entry-box caution blue" aria-label="0B1R caution entry">
          <div class="caution-row blue">0B</div>
          <div class="caution-row red">1R</div>
        </div>
        <div class="entry-time">1:02</div>
      </div>
      <div id="next-event" class="entry">
        <div class="entry-box next">+</div>
        <div class="entry-time">Next</div>
      </div>
    </section>

    <section id="buttons" class="buttons" aria-label="Bout Buttons">
      <article id="buttons-red" class="button-side red" aria-label="Red Button Column">
        <div class="injury-grid" aria-label="Red Injury Times">
          <button id="injury-time-red" class="mini-time" type="button">TIR 0:00</button>
          <button id="blood-time-red" class="mini-time" type="button">TBR 0:00</button>
        </div>
        <div id="event-buttons-red" class="event-grid" aria-label="Red Event Buttons">
          <button class="event-btn" type="button">[1R]</button>
          <button class="event-btn" type="button">[4R]</button>
          <button class="event-btn" type="button">[5R]</button>
          <button class="event-btn" type="button">[2R]</button>
          <button class="event-btn" type="button">[PR]</button>
          <button class="event-btn" type="button">[0R]</button>
        </div>
      </article>

      <article id="center" class="center" aria-label="Timing">
        <button class="bout-time" type="button" id="bout-time-button" aria-label="Bout Time Toggle">
          <div class="time-label">Kampfzeit</div>
          <div id="bout-time-display" class="time">3:00</div>
          <div class="time-note">[Leertaste]</div>
        </button>
        <button id="release-complete-button" class="action" type="button" aria-label="Release">Freigeben [F4]</button>
      </article>

      <article id="buttons-blue" class="button-side blue" aria-label="Blue Button Column">
        <div class="injury-grid" aria-label="Blue Injury Times">
          <button id="blood-time-blue" class="mini-time" type="button">TBB 0:00</button>
          <button id="injury-time-blue" class="mini-time" type="button">TIB 0:00</button>
        </div>
        <div id="event-buttons-blue" class="event-grid" aria-label="Blue Event Buttons">
            <button class="event-btn" type="button">[5B]</button>
            <button class="event-btn" type="button">[4B]</button>
            <button class="event-btn" type="button">[1B]</button>
            <button class="event-btn" type="button">[0B]</button>
            <button class="event-btn" type="button">[PB]</button>
            <button class="event-btn" type="button">[2B]</button>
        </div>
      </article>
    </section>
  </main>

  <div hidden>
    <button id="start" type="button">Start</button>
    <button id="stop" type="button">Stop</button>
  </div>

  <script>
    const START_TIME_SECONDS = 3 * 60;
    let remainingSeconds = START_TIME_SECONDS;
    let intervalId = null;

    const display = document.getElementById("display");
    const startButton = document.getElementById("start");
    const stopButton = document.getElementById("stop");
    const boutTimeButton = document.getElementById("bout-time-button");

    function updateDisplay() {
      const minutes = Math.floor(remainingSeconds / 60);
      const seconds = remainingSeconds % 60;
      display.textContent =
        minutes + ":" + seconds.toString().padStart(2, "0");
    }
    function tick() {
      if (remainingSeconds > 0) {
        remainingSeconds--;
        updateDisplay();
      } else {
        stopTimer();
      }
    }
    function startTimer() {
      if (intervalId !== null) return;
      intervalId = setInterval(tick, 1000);
    }
    function stopTimer() {
      clearInterval(intervalId);
      intervalId = null;
    }

    function toggleTimer() {
      if (intervalId === null) {
        startTimer();
        return;
      }
      stopTimer();
    }

    startButton.addEventListener("click", startTimer);
    stopButton.addEventListener("click", stopTimer);
    boutTimeButton.addEventListener("click", toggleTimer);
    updateDisplay();

    // --- Ruleset helper -------------------------------------------------
    function loadEmbeddedRuleset() {
      const el = document.getElementById('default-ruleset');
      if (!el) return null;
      try {
        return JSON.parse(el.textContent);
      } catch (e) {
        console.error('Failed to parse embedded ruleset:', e);
        return null;
      }
    }

    function simpleValidateRuleset(r) {
      const errors = [];
      if (!r) { errors.push('ruleset missing'); return { valid: false, errors }; }
      if (!r.metadata || typeof r.metadata.name !== 'string') errors.push('metadata.name required');
      if (!Array.isArray(r.periodTimesInSeconds)) errors.push('periodTimesInSeconds array required');
      if (typeof r.periodTimeCountingDirection !== 'string') errors.push('periodTimeCountingDirection required');
      if (typeof r.periodBreakTimeInSeconds !== 'number') errors.push('periodBreakTimeInSeconds required');
      if (!Array.isArray(r.victoryTypes)) errors.push('victoryTypes array required');
      if (Array.isArray(r.victoryTypes)) {
        r.victoryTypes.forEach((vt, i) => {
          if (typeof vt.type !== 'string') errors.push(`victoryTypes[${i}].type required`);
          if (!Array.isArray(vt.classificationPoints) || vt.classificationPoints.length !== 2) errors.push(`victoryTypes[${i}].classificationPoints must be [win,lose]`);
          if (vt.condition && typeof vt.condition === 'object') {
            Object.values(vt.condition).forEach(op => {
              if (typeof op !== 'object') errors.push(`victoryTypes[${i}].condition entries must be objects`);
            });
          }
        });
      }
      return { valid: errors.length === 0, errors };
    }

    function evalOperator(value, op, target) {
      if (op.gte !== undefined && !(value >= op.gte)) return false;
      if (op.lte !== undefined && !(value <= op.lte)) return false;
      if (op.gt !== undefined && !(value > op.gt)) return false;
      if (op.lt !== undefined && !(value < op.lt)) return false;
      if (op.eq !== undefined && !(value === op.eq)) return false;
      return true;
    }

    function evaluateCondition(condition, context) {
      if (!condition) return true;
      // All named condition fields must be satisfied (AND)
      for (const key in condition) {
        const op = condition[key];
        const value = context[key];
        if (value === undefined) return false;
        if (!evalOperator(value, op, key)) return false;
      }
      return true;
    }

    function findMatchingVictoryTypes(ruleset, context) {
      if (!ruleset || !Array.isArray(ruleset.victoryTypes)) return [];
      return ruleset.victoryTypes.filter(vt => {
        if (!vt.condition) return true;
        return evaluateCondition(vt.condition, context);
      });
    }

    // Expose helper
    window.rulesetHelper = {
      load: loadEmbeddedRuleset,
      validate: simpleValidateRuleset,
      evaluateCondition,
      findMatchingVictoryTypes
    };

    // Auto-load and validate at startup (logs result)
    const _embeddedRuleset = loadEmbeddedRuleset();
    const _valid = simpleValidateRuleset(_embeddedRuleset);
    if (!_valid.valid) console.warn('Embedded ruleset validation warnings:', _valid.errors);

    // --- Export functionality --------------------------------------------
    // Placeholder data structures (to be replaced with actual app state)
    const boutState = {
      createdAt: null,
      events: [],
      sequenceCounter: 0,
      completed: false,
      completedAt: null,
      victoryType: null,
      classificationPoints: null
    };

    function getSystemMetadata() {
      return {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        languages: Array.from(navigator.languages || [navigator.language]),
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        timestamp: new Date().toISOString(),
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timezoneOffset: new Date().getTimezoneOffset()
      };
    }

    function parseInfo(infoString) {
      // Parse key-value pairs from info string (spec: key:value; separator)
      const pairs = {};
      const segments = infoString.split(';').map(s => s.trim());
      let anonCounter = 1;
      
      segments.forEach(seg => {
        if (!seg) return;
        const colonIdx = seg.indexOf(':');
        if (colonIdx === -1) {
          pairs[`$anonym${anonCounter++}`] = seg;
        } else {
          let key = seg.substring(0, colonIdx).trim();
          const value = seg.substring(colonIdx + 1).trim();
          
          if (key.startsWith('$$')) {
            // Hidden pair - don't include in parsedInfo
            return;
          }
          if (key.startsWith('$')) {
            pairs[`anonym${anonCounter++}`] = value;
          } else {
            pairs[key.toLowerCase()] = value;
          }
        }
      });
      return pairs;
    }

    function calculateStatistics(events) {
      const stats = {
        red: {
          technicalPoints: { "1": 0, "2": 0, "4": 0, "5": 0 },
          passivity: 0,
          cautions: 0,
          injuryTime100ms: 0,
          bloodTime100ms: 0
        },
        blue: {
          technicalPoints: { "1": 0, "2": 0, "4": 0, "5": 0 },
          passivity: 0,
          cautions: 0,
          injuryTime100ms: 0,
          bloodTime100ms: 0
        },
        totalEvents: events.length,
        corrections: 0
      };

      events.forEach(e => {
        // Technical points
        const pointMatch = e.eventType.match(/^([1245])(R|B)$/);
        if (pointMatch) {
          const points = pointMatch[1];
          const side = pointMatch[2] === 'R' ? 'red' : 'blue';
          stats[side].technicalPoints[points]++;
        }
        
        // Passivity
        if (e.eventType === 'PR') stats.red.passivity++;
        if (e.eventType === 'PB') stats.blue.passivity++;
        
        // Cautions
        if (e.eventType.match(/^0R[12]B$/)) stats.red.cautions++;
        if (e.eventType.match(/^0B[12]R$/)) stats.blue.cautions++;
        
        // Corrections
        if (e.eventType.startsWith('Event') || e.eventType.includes('_Modified')) {
          stats.corrections++;
        }
      });

      return stats;
    }

    function calculateScores(events) {
      const scores = { red: 0, blue: 0 };
      
      events.forEach(e => {
        const pointMatch = e.eventType.match(/^([1245])(R|B)$/);
        if (pointMatch) {
          const points = parseInt(pointMatch[1]);
          const side = pointMatch[2] === 'R' ? 'red' : 'blue';
          scores[side] += points;
        }
        
        // Cautions award points to opponent
        const cautionMatch = e.eventType.match(/^0([RB])([12])([RB])$/);
        if (cautionMatch) {
          const points = parseInt(cautionMatch[2]);
          const recipient = cautionMatch[3] === 'R' ? 'red' : 'blue';
          scores[recipient] += points;
        }
      });
      
      return scores;
    }

    function generateExport() {
      const ruleset = loadEmbeddedRuleset();
      const boutInfo = document.getElementById('bout-info')?.value || '';
      const style = document.getElementById('style-select')?.value || 'Freestyle';
      const rulesetName = document.getElementById('ruleset-select')?.value || 'Default Ruleset';
      const redInfo = document.getElementById('info-red')?.textContent || 'Rot';
      const blueInfo = document.getElementById('info-blue')?.textContent || 'Blau';
      
      const scores = calculateScores(boutState.events);
      const statistics = calculateStatistics(boutState.events);
      
      // Calculate winner
      let winner = 'none';
      if (boutState.completed && scores.red > scores.blue) winner = 'red';
      else if (boutState.completed && scores.blue > scores.red) winner = 'blue';
      else if (boutState.completed && scores.red === scores.blue) winner = 'draw';
      
      // Calculate total bout time
      let totalBoutTime100ms = 0;
      if (boutState.events.length > 0) {
        const lastBoutEvent = boutState.events
          .filter(e => e.boutTime100ms !== undefined)
          .pop();
        if (lastBoutEvent) totalBoutTime100ms = lastBoutEvent.boutTime100ms;
      }
      
      // Calculate real time duration
      let totalRealTime = 0;
      if (boutState.createdAt && boutState.completedAt) {
        totalRealTime = new Date(boutState.completedAt) - new Date(boutState.createdAt);
      }
      
      // Filter timeline (only bout events)
      const timeline = boutState.events.filter(e => 
        e.boutTime100ms !== undefined && 
        !e.eventType.startsWith('T_') &&
        !e.eventType.startsWith('Event') &&
        !e.eventType.includes('_Modified')
      ).map(e => ({
        seq: e.seq,
        eventType: e.eventType,
        boutTime100ms: e.boutTime100ms
      }));

      const exportData = {
        "$schema": "./export-v1.schema.json",
        "exportVersion": "1.0",
        "metadata": {
          "app": {
            "name": "CHAMP Protocol",
            "version": "1.0.0",
            "build": "2025-01-15T10:30:00Z"
          },
          "system": getSystemMetadata()
        },
        "bout": {
          "header": {
            "createdAt": boutState.createdAt || new Date().toISOString(),
            "info": boutInfo,
            "style": style,
            "ruleset": {
              "reference": ruleset?.metadata?.name || rulesetName,
              "embedded": ruleset
            },
            "wrestlers": {
              "red": {
                "info": redInfo,
                "parsedInfo": parseInfo(redInfo)
              },
              "blue": {
                "info": blueInfo,
                "parsedInfo": parseInfo(blueInfo)
              }
            }
          },
          "summary": {
            "completed": boutState.completed,
            "completedAt": boutState.completedAt,
            "duration": {
              "totalBoutTime100ms": totalBoutTime100ms,
              "totalRealTime": totalRealTime,
              "periods": []
            },
            "scores": scores,
            "winner": winner,
            "victory": boutState.victoryType ? {
              "type": boutState.victoryType,
              "description": "",
              "classificationPoints": boutState.classificationPoints || [0, 0]
            } : undefined,
            "statistics": statistics,
            "timeline": timeline,
            "notes": ""
          },
          "events": boutState.events
        }
      };

      return exportData;
    }

    function downloadExport() {
      const exportData = generateExport();
      const jsonString = JSON.stringify(exportData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
      const filename = `champ-export-${timestamp}.json`;
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('Export downloaded:', filename);
    }

    // Expose export helper
    window.exportHelper = {
      generate: generateExport,
      download: downloadExport
    };
  </script>

  <!-- Embedded default ruleset: protocol/rulesets/ruleset-default.json -->
  <script id="default-ruleset" type="application/json">
  {
    "metadata": {
      "name": "de-mannschaftskampf-2025",
      "description": "Deutsches Regelwerk für Mannschaftskämpfe",
      "languages": ["de"],
      "author": "Deutscher Ringer-Bund"
    },
    "periodTimesInSeconds": [180, 180],
    "periodTimeCountingDirection": "Down",
    "periodBreakTimeInSeconds": 30,
    "injuryTimeWithoutBloodInSeconds": 120,
    "injuryTimeWithBloodInSeconds": 240,
    "injuryTimeCountingDirection": "Up",
    "freestyle": {
      "activityTimeInSeconds": 30,
      "activityTimeCountingDirection": "Down",
      "activityTimeCondition": {
        "passivityCount": { "gt": 1 }
      }
    },
    "victoryTypes": [
      { "type": "SS", "description": "Schultersieg", "classificationPoints": [4, 0] },
      {
        "type": "TÜ",
        "description": "Technische Überlegenheit",
        "classificationPoints": [4, 0],
        "condition": { "scoreDifference": { "gte": 15 } }
      },
      {
        "type": "PS",
        "description": "Punktsieg",
        "classificationPoints": [3, 0],
        "condition": { "scoreDifference": { "gte": 8, "lte": 14 } }
      },
      {
        "type": "PS",
        "description": "Punktsieg",
        "classificationPoints": [2, 0],
        "condition": { "scoreDifference": { "gte": 3, "lte": 7 } }
      },
      {
        "type": "PS",
        "description": "Punktsieg",
        "classificationPoints": [1, 0],
        "condition": { "scoreDifference": { "gte": 0, "lte": 2 } }
      },
      { "type": "AS", "description": "Aufgabesieg", "classificationPoints": [4, 0] },
      { "type": "DV", "description": "Disqualifikation durch 3 Verwarnungen", "classificationPoints": [4, 0], "condition": { "cautionCount": { "gte": 3 } } },
      { "type": "DQ", "description": "Disqualifikation durch unfaires Verhalten", "classificationPoints": [4, 0] },
      { "type": "DSQ2", "description": "Beide Ringer disqualifiziert wegen unfairem Verhalten", "classificationPoints": [0, 0] },
      { "type": "KL", "description": "Kampfloser Sieg", "classificationPoints": [4, 0] },
      { "type": "ÜG", "description": "Übergewicht", "classificationPoints": [4, 0] }
    ]
  }
  </script>
</body>
</html>