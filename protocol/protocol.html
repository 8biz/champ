<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Protocol â€“ Countdown</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #f4f4f4;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .timer {
      background: white;
      padding: 2rem 3rem;
      border-radius: 8px;
      text-align: center;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      width: min(980px, 92%);
    }
    .time {
      font-size: 4rem;
      font-variant-numeric: tabular-nums;
      margin-bottom: 1.5rem;
    }
    button {
      font-size: 1rem;
      padding: 0.5rem 1.2rem;
      margin: 0 0.5rem;
      cursor: pointer;
    }

    /* Timeline styles */
    .timeline {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding: 8px 6px;
      border: 1px solid #e6e6e6;
      border-radius: 6px;
      background: #fff9f2;
      align-items: flex-start;
      min-height: 86px;
    }
    .slot {
      min-width: 80px;
      flex: 0 0 auto;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 6px;
      box-sizing: border-box;
      position: relative;
    }
    .slot.next-slot { opacity: 0.8; background: #f4f4f4 }
    .slot .scoreTop { font-weight: 600; color: #333; font-size: 0.9rem }
    .slot .eventCenter { font-size: 1.2rem; margin: 6px 0; font-weight: 700 }
    .slot .timeBottom { font-size: 0.85rem; color: #666 }
    .slot.cursor { outline: 3px solid #0077B6; box-shadow: 0 0 0 3px rgba(0,119,182,0.12) }

    .slot.red .eventCenter { color: #C1121F }
    .slot.blue .eventCenter { color: #0077B6 }

    .period-divider {
      width: 8px;
      background: linear-gradient(to bottom, #333, #666);
      border-radius: 2px;
      align-self: stretch;
      margin-left: 2px;
      margin-right: 2px;
    }
  </style>
</head>
<body>
  <div class="timer">
    <div class="time" id="display">3:00</div>
    <div style="margin-top:1rem">
      <button id="start">Start</button>
      <button id="stop">Stopp</button>
      <span style="margin-left:1rem">Buffer: <strong id="buffer"></strong></span>
    </div>
    <div style="margin-top:1rem">
      <div><strong>Last event:</strong> <span id="lastEvent">(none)</span></div>
      <div id="timelineContainer" style="margin-top:0.5rem">
        <div id="timeline" class="timeline" role="list" aria-label="Timeline"></div>
      </div>
    </div>
  </div>
  <script>
    // Enhanced FSM port + timeline with period handling
    class KeyboardFSM {
      constructor() { this.buffer = [] }
      normalizeKey(raw) {
        if (!raw) return ''
        if (raw === ' ' || raw === 'Spacebar' || raw === 'Space') return 'Space'
        if (raw === 'Escape') return 'Escape'
        if (raw === 'Enter') return 'Enter'
        if (raw === 'Delete') return 'Delete'
        if (raw === 'Backspace') return 'Backspace'
        if (raw === 'ArrowLeft') return 'ArrowLeft'
        if (raw === 'ArrowRight') return 'ArrowRight'
        if (raw.length === 1) return raw.toUpperCase()
        return raw.toUpperCase()
      }
      getBuffer() { return [...this.buffer] }
      resetBuffer() { this.buffer = [] }
      handleKey(rawKey, mode='normal') {
        const key = this.normalizeKey(rawKey)
        if (key === 'Space') { this.resetBuffer(); return { action: { type: 'ToggleBoutTime' }, buffer: this.getBuffer() } }
        if (key === 'Escape') { this.resetBuffer(); return { action: { type: 'BufferCleared' }, buffer: this.getBuffer() } }
        if (mode === 'correction') {
          if (key === 'Delete') { this.resetBuffer(); return { action: { type: 'DeleteEvent' }, buffer: this.getBuffer() } }
          if (key === 'Enter') { this.resetBuffer(); return { action: { type: 'Confirm' }, buffer: this.getBuffer() } }
          if (key === 'Backspace' || key === 'ArrowLeft') { this.resetBuffer(); return { action: { type: 'MoveCursor', dir: 'left' }, buffer: this.getBuffer() } }
          if (key === 'ArrowRight') { this.resetBuffer(); return { action: { type: 'MoveCursor', dir: 'right' }, buffer: this.getBuffer() } }
        } else {
          if (key === 'Backspace') return { action: null, buffer: this.getBuffer() }
        }
        const actor = this.buffer[0]
        if (key === 'R' || key === 'B') { this.buffer = [key]; return { action: null, buffer: this.getBuffer() } }
        if (!actor) { return { action: null, buffer: this.getBuffer() } }
        if ((key === '1' || key === '2' || key === '4') && this.buffer.length === 1) {
          const points = key === '1' ? 1 : key === '2' ? 2 : 4
          const action = { type: 'Point', actor: actor, points }
          this.resetBuffer(); return { action, buffer: this.getBuffer() }
        }
        if (key === 'P' && this.buffer.length === 1) { const action = { type: 'Passivity', actor }; this.resetBuffer(); return { action, buffer: this.getBuffer() } }
        if (key === '0' && this.buffer.length === 1) { this.buffer.push('0'); return { action: null, buffer: this.getBuffer() } }
        if ((key === '1' || key === '2') && this.buffer.length === 2 && this.buffer[1] === '0') {
          const points = key === '1' ? 1 : 2
          const awardedTo = actor === 'R' ? 'B' : 'R'
          const action = { type: 'Caution', actor, awardedTo, points }
          this.resetBuffer(); return { action, buffer: this.getBuffer() }
        }
        if ((key === '+' || key === '*') && this.buffer.length === 1) { const action = { type: 'InjuryToggle', actor, blood: key === '*' }; this.resetBuffer(); return { action, buffer: this.getBuffer() } }
        return { action: null, buffer: this.getBuffer() }
      }
    }

    // Allow test control of period length via ?period=SECONDS (useful for Playwright)
    const params = new URLSearchParams(window.location.search)
    const START_TIME_SECONDS = parseInt(params.get('period') || '') || 3 * 60
    const PERIOD_COUNT = parseInt(params.get('periods') || '') || 2

    let remainingSeconds = START_TIME_SECONDS
    let intervalId = null
    let periodIndex = 0
    const periodScores = [{ red: 0, blue: 0 }]

    const display = document.getElementById('display')
    const startButton = document.getElementById('start')
    const stopButton = document.getElementById('stop')
    const bufferEl = document.getElementById('buffer')
    const lastEventEl = document.getElementById('lastEvent')
    const timelineEl = document.getElementById('timeline')

    function formatSeconds(sec) {
      const minutes = Math.floor(sec / 60)
      const seconds = sec % 60
      return `${minutes}:${String(seconds).padStart(2, '0')}`
    }

    function updateDisplay() {
      display.textContent = formatSeconds(remainingSeconds)
    }

    function stopTimer(internal = false) {
      if (intervalId === null) return
      clearInterval(intervalId)
      intervalId = null
      // if stopping due to reaching zero, handle period end
      if (remainingSeconds <= 0 && internal) {
        // push PERIOD_END event
        const ev = {
          seq: seq++,
          eventCode: 'PERIOD_END',
          periodIndex,
          boutTimeSeconds: START_TIME_SECONDS,
          periodScoreRed: periodScores[periodIndex].red,
          periodScoreBlue: periodScores[periodIndex].blue,
          isPeriodEnd: true,
          timestamp: new Date().toISOString(),
        }
        events.push(ev)
        renderEvents()
        if (periodIndex < PERIOD_COUNT - 1) {
          periodIndex++
          periodScores.push({ red: 0, blue: 0 })
          remainingSeconds = START_TIME_SECONDS
          updateDisplay()
        }
      }
    }

    function tick() {
      if (remainingSeconds > 0) {
        remainingSeconds--
        updateDisplay()
        if (remainingSeconds === 0) {
          stopTimer(true)
        }
      }
    }

    function startTimer() { if (intervalId !== null) return; intervalId = setInterval(tick, 1000) }
    startButton.addEventListener('click', startTimer)
    stopButton.addEventListener('click', () => stopTimer(false))
    updateDisplay()

    // Timeline & events model
    const events = [] // array of { seq, eventCode, periodIndex, boutTimeSeconds, periodScoreRed, periodScoreBlue, isPeriodEnd, timestamp }
    let seq = 0
    let mode = 'normal' // 'normal' | 'correction'
    let cursor = null // index in events array when in correction mode
    const fsm = new KeyboardFSM()

    function renderEvents() {
      timelineEl.innerHTML = ''
      events.forEach((e, idx) => {
        const slot = document.createElement('div')
        slot.className = 'slot'
        if (e.isPeriodEnd) slot.classList.add('period-end')
        // actor color
        const actor = (/^[RB]/.test(e.eventCode) && e.eventCode[0]) || ''
        if (actor === 'R') slot.classList.add('red')
        if (actor === 'B') slot.classList.add('blue')
        slot.dataset.seq = String(e.seq)
        slot.dataset.timestamp = e.timestamp || ''
        slot.dataset.bouttime = String(e.boutTimeSeconds ?? '')
        slot.dataset.period = String(e.periodIndex ?? '')
        slot.dataset.score = `${e.periodScoreRed ?? 0}-${e.periodScoreBlue ?? 0}`
        slot.innerHTML = `<div class="scoreTop">${e.periodScoreRed ?? 0}-${e.periodScoreBlue ?? 0}</div><div class="eventCenter">${e.eventCode}</div><div class="timeBottom">${formatSeconds(e.boutTimeSeconds ?? 0)}</div>`
        slot.addEventListener('click', () => { mode = 'correction'; cursor = idx; renderEvents() })
        if (mode === 'correction' && cursor === idx) slot.classList.add('cursor')
        timelineEl.appendChild(slot)
        if (e.isPeriodEnd) {
          const divider = document.createElement('div')
          divider.className = 'period-divider'
          timelineEl.appendChild(divider)
        }
      })

      // next placeholder
      if (mode === 'normal') {
        const next = document.createElement('div')
        next.className = 'slot next-slot'
        next.innerHTML = `<div class="scoreTop">${periodScores[periodIndex].red}-${periodScores[periodIndex].blue}</div><div class="eventCenter">N</div><div class="timeBottom">${formatSeconds(getCurrentBoutTimeSeconds())}</div>`
        timelineEl.appendChild(next)
      }

      lastEventEl.textContent = events.length ? events[events.length - 1].eventCode : '(none)'
    }

    function getCurrentBoutTimeSeconds() {
      // seconds since period start
      return START_TIME_SECONDS - remainingSeconds
    }

    function applyAction(action) {
      if (!action) return
      switch (action.type) {
        case 'ToggleBoutTime': if (intervalId === null) startTimer(); else stopTimer(false); break
        case 'Point': {
          const code = `${action.actor}${action.points}`
          const bt = getCurrentBoutTimeSeconds()
          if (mode === 'normal') {
            // update score
            if (action.actor === 'R') periodScores[periodIndex].red += action.points
            else periodScores[periodIndex].blue += action.points
            const ev = {
              seq: seq++,
              eventCode: code,
              periodIndex,
              boutTimeSeconds: bt,
              periodScoreRed: periodScores[periodIndex].red,
              periodScoreBlue: periodScores[periodIndex].blue,
              isPeriodEnd: false,
              timestamp: new Date().toISOString(),
            }
            events.push(ev)
          } else if (mode === 'correction' && cursor != null) {
            // change eventCode but keep other fields except timestamp
            events[cursor].eventCode = code
            events[cursor].timestamp = new Date().toISOString()
          }
          renderEvents(); break
        }
        case 'Passivity': {
          const code = `${action.actor}P`
          const bt = getCurrentBoutTimeSeconds()
          if (mode === 'normal') {
            const ev = { seq: seq++, eventCode: code, periodIndex, boutTimeSeconds: bt, periodScoreRed: periodScores[periodIndex].red, periodScoreBlue: periodScores[periodIndex].blue, isPeriodEnd: false, timestamp: new Date().toISOString() }
            events.push(ev)
          } else if (mode === 'correction' && cursor != null) { events[cursor].eventCode = code; events[cursor].timestamp = new Date().toISOString() }
          renderEvents(); break
        }
        case 'Caution': {
          const code = `${action.actor}0${action.points}${action.awardedTo}`
          const bt = getCurrentBoutTimeSeconds()
          if (mode === 'normal') {
            // award to opponent
            if (action.awardedTo === 'R') periodScores[periodIndex].red += action.points
            else periodScores[periodIndex].blue += action.points
            const ev = { seq: seq++, eventCode: code, periodIndex, boutTimeSeconds: bt, periodScoreRed: periodScores[periodIndex].red, periodScoreBlue: periodScores[periodIndex].blue, isPeriodEnd: false, timestamp: new Date().toISOString() }
            events.push(ev)
          } else if (mode === 'correction' && cursor != null) { events[cursor].eventCode = code; events[cursor].timestamp = new Date().toISOString() }
          renderEvents(); break
        }
        case 'InjuryToggle': {
          const code = `${action.actor}${action.blood ? '*' : '+'}`
          const bt = getCurrentBoutTimeSeconds()
          if (mode === 'normal') { const ev = { seq: seq++, eventCode: code, periodIndex, boutTimeSeconds: bt, periodScoreRed: periodScores[periodIndex].red, periodScoreBlue: periodScores[periodIndex].blue, isPeriodEnd: false, timestamp: new Date().toISOString() }; events.push(ev) }
          else if (mode === 'correction' && cursor != null) { events[cursor].eventCode = code; events[cursor].timestamp = new Date().toISOString() }
          renderEvents(); break
        }
        case 'BufferCleared': bufferEl.textContent = ''; break
        case 'DeleteEvent': if (mode === 'correction' && cursor != null) { events.splice(cursor, 1); cursor = null; mode = 'normal'; renderEvents() } break
        case 'Confirm': cursor = null; mode = 'normal'; renderEvents(); break
        case 'MoveCursor': {
          if (action.dir === 'left') {
            if (cursor == null) cursor = events.length - 1
            else cursor = Math.max(0, cursor - 1)
            mode = 'correction'
            renderEvents()
          } else {
            if (cursor == null) cursor = 0
            else cursor = Math.min(events.length - 1, cursor + 1)
            mode = 'correction'
            renderEvents()
          }
          break
        }
        default: break
      }
    }

    // Key handling - keep FSM usage in one place
    window.addEventListener('keydown', (ev) => {
      // ArrowLeft from normal enters correction mode selecting last slot if no buffer
      if (ev.key === 'ArrowLeft' && mode === 'normal' && events.length > 0 && fsm.getBuffer().length === 0) {
        mode = 'correction'
        cursor = events.length - 1
        renderEvents()
        return
      }
      const res = fsm.handleKey(ev.key, mode)
      // Update buffer UI
      bufferEl.textContent = res.buffer.join(' ')
      if (res.action) applyAction(res.action)
    })

  </script>
</body>
</html>