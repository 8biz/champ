<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CHAMP Protocol – Prototype</title>
  <style>
    * {
      box-sizing: border-box;
    }

    :root {
      --red: #d33131;
      --blue: #1975d2;
      --neutral-1: #f5f5f5;
      --neutral-2: #9e9e9e;
      --neutral-3: #616161;
      --border: #c9c9c9;
      --text: #1f1f1f;
    }

    html,
    body {
      margin: 0;
      min-width: 320px;
      min-height: 320px;
      height: 100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: var(--neutral-1);
    }

    body {
      padding: 0.5rem;
    }

    .app {
      height: calc(100vh - 1rem);
      min-height: 304px;
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 8px;
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      gap: 0.5rem;
      padding: 0.5rem;
      overflow: hidden;
    }

    .top-bar {
      display: grid;
      grid-template-columns: minmax(120px, 1fr) auto auto auto;
      gap: 0.5rem;
      align-items: center;
    }

    .field,
    .select,
    .action {
      min-height: 2.25rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      padding: 0 0.6rem;
      font-size: 0.92rem;
    }

    .action {
      font-weight: 600;
      cursor: pointer;
    }

    /* Mirror the pencil glyph for the blue side's header action button */
    .side.blue .side-head .action {
      display: inline-block;
      transform: scaleX(-1);
      line-height: 1;
    }

    .board {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      min-height: 0;
    }

    .buttons {
      display: grid;
      grid-template-columns: 1fr minmax(130px, 180px) 1fr;
      gap: 0.5rem;
      min-height: 0;
    }

    .side {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      gap: 0.45rem;
      min-height: 0;
    }

    .button-side {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 0.45rem;
      min-height: 0;
    }

    .side.red {
      background: color-mix(in srgb, var(--red) 8%, white);
    }

    .side.blue {
      background: color-mix(in srgb, var(--blue) 8%, white);
    }

    .button-side.red {
      background: color-mix(in srgb, var(--red) 8%, white);
    }

    .button-side.blue {
      background: color-mix(in srgb, var(--blue) 8%, white);
    }

    .side-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 700;
    }

    .score {
      font-size: clamp(2rem, 5vw, 3.4rem);
      font-variant-numeric: tabular-nums;
      line-height: 1;
      font-weight: 700;
      text-align: center;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      padding: 0.2rem 0;
    }

    .injury-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.4rem;
    }

    .mini-time {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      padding: 0.35rem;
      text-align: center;
      font-size: 0.82rem;
      font-variant-numeric: tabular-nums;
    }

    .event-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.35rem;
      align-content: start;
    }

    .event-btn {
      border: 1px solid transparent;
      border-radius: 6px;
      min-height: 3rem;
      font-weight: 700;
      font-size: 0.9rem;
      cursor: default;
      color: #fff;
    }

    .red .event-btn {
      background: var(--red);
      border-color: var(--red);
    }

    .blue .event-btn {
      background: var(--blue);
      border-color: var(--blue);
    }

    .center {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem;
      display: grid;
      grid-template-rows: auto auto auto 1fr;
      gap: 0.5rem;
      align-content: start;
    }

    .mode-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.35rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--neutral-1);
      padding: 0.25rem 0.35rem;
    }

    .mode-chip {
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      padding: 0.16rem 0.45rem;
      border: 1px solid var(--neutral-3);
      color: var(--neutral-3);
      background: #fff;
    }

    .mode-chip.active {
      background: var(--neutral-3);
      color: #fff;
    }

    .mode-hint {
      font-size: 0.72rem;
      color: var(--neutral-3);
      font-weight: 600;
    }

    .time-label {
      text-align: center;
      color: var(--neutral-3);
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .bout-time {
      border: 2px solid var(--neutral-3);
      border-radius: 10px;
      background: #fff;
      padding: 0.6rem 0.3rem;
      cursor: pointer;
      text-align: center;
    }

    .time {
      font-size: clamp(2.2rem, 6vw, 3rem);
      font-variant-numeric: tabular-nums;
      font-weight: 700;
      line-height: 1;
    }

    .time-note {
      margin-top: 0.2rem;
      font-size: 0.72rem;
      color: var(--neutral-3);
    }

    .timeline {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.4rem;
      display: flex;
      gap: 0.4rem;
      overflow-x: auto;
      align-items: flex-start;
    }

    .entry {
      min-width: 50px;
      display: grid;
      gap: 0.15rem;
      justify-items: center;
    }

    .entry-box {
      width: 50px;
      height: 40px;
      border-radius: 4px;
      border: 2px solid;
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #fff;
      font-size: 0.92rem;
    }

    .entry-box.caution {
      display: grid;
      grid-template-rows: 1fr 1fr;
      padding: 0;
      overflow: hidden;
      background: #fff;
    }

    .entry-box.caution.blue {
      border-color: var(--blue);
    }

    .entry-box.caution.red {
      border-color: var(--red);
    }

    .caution-row {
      width: 100%;
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 0.82rem;
      line-height: 1;
      color: #fff;
    }

    .caution-row.blue {
      background: var(--blue);
    }

    .caution-row.red {
      background: var(--red);
    }

    .entry-box.red {
      background: var(--red);
      border-color: var(--red);
    }

    .entry-box.blue {
      background: var(--blue);
      border-color: var(--blue);
    }

    .entry-box.next {
      background: var(--neutral-1);
      border-color: var(--neutral-3);
      border-style: dashed;
      color: var(--neutral-3);
    }

    .entry-box.cursor {
      border-color: var(--neutral-3);
      box-shadow: 0 0 0 2px #fff, 0 0 0 4px var(--neutral-3);
    }

    .entry-time {
      font-size: 0.72rem;
      color: var(--neutral-3);
      font-variant-numeric: tabular-nums;
    }

    .correction-bar {
      display: flex;
      gap: 0.3rem;
      align-items: center;
      flex-wrap: wrap;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.35rem;
      background: #fff;
    }

    .correction-action {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--neutral-1);
      color: var(--neutral-3);
      font-size: 0.76rem;
      font-weight: 700;
      padding: 0.24rem 0.5rem;
      white-space: nowrap;
    }

    .correction-action.primary {
      background: var(--neutral-3);
      border-color: var(--neutral-3);
      color: #fff;
    }

    @media (max-width: 850px) {
      .board,
      .buttons {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        overflow: auto;
      }

      .buttons .center {
        order: -1;
      }
    }

    @media (max-height: 420px) {
      .event-btn {
        min-height: 1.6rem;
      }

      .score {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>
  <main id="app" class="app" aria-label="CHAMP Protocol Prototype">
    <section id="top-bar" class="top-bar" aria-label="Scoresheet Header">
      <input id="bout-info" class="field" type="text" value="Wettkampf: Landesmeisterschaft; U17 74kg" aria-label="Bout Info" />
      <select id="style-select" class="select" aria-label="Style">
        <option selected>Freestyle</option>
        <option>Greco-Roman</option>
      </select>
      <select id="ruleset-select" class="select" aria-label="Ruleset">
        <option selected>Default Ruleset</option>
      </select>
    </section>

    <section id="board" class="board" aria-label="Bout Area">
      <article id="side-red" class="side red" aria-label="Wrestler Red">
        <header id="info-red" class="side-head"><button class="action" type="button" aria-label="Bearbeiten">✎</button><span>Rot</span></header>
        <div id="score-red" class="score" aria-label="Score Red">0</div>
      </article>

      <article id="side-blue" class="side blue" aria-label="Wrestler Blue">
        <header id="info-blue" class="side-head"><span>Blau</span><button class="action" type="button" aria-label="Bearbeiten">✎</button></header>
        <div id="score-blue" class="score" aria-label="Score Blue">0</div>
      </article>
    </section>

    <section id="timeline" class="timeline" aria-label="Timeline">
      <!-- Events will be added dynamically -->
    </section>

    <section id="buttons" class="buttons" aria-label="Bout Buttons">
      <article id="buttons-red" class="button-side red" aria-label="Red Button Column">
        <div class="injury-grid" aria-label="Red Injury Times">
          <button id="injury-time-red" class="mini-time" type="button">TIR 0:00</button>
          <button id="blood-time-red" class="mini-time" type="button">TBR 0:00</button>
        </div>
        <div id="event-buttons-red" class="event-grid" aria-label="Red Event Buttons">
          <button class="event-btn" type="button">[1R]</button>
          <button class="event-btn" type="button">[4R]</button>
          <button class="event-btn" type="button">[5R]</button>
          <button class="event-btn" type="button">[2R]</button>
          <button class="event-btn" type="button">[PR]</button>
          <button class="event-btn" type="button">[0R]</button>
        </div>
      </article>

      <article id="center" class="center" aria-label="Timing">
        <button class="bout-time" type="button" id="bout-time-button" aria-label="Bout Time Toggle">
          <div class="time-label">Kampfzeit</div>
          <div id="bout-time-display" class="time">3:00</div>
          <div class="time-note">[Leertaste]</div>
        </button>
        <button id="release-complete-button" class="action" type="button" aria-label="Release">Freigeben [F4]</button>
      </article>

      <article id="buttons-blue" class="button-side blue" aria-label="Blue Button Column">
        <div class="injury-grid" aria-label="Blue Injury Times">
          <button id="blood-time-blue" class="mini-time" type="button">TBB 0:00</button>
          <button id="injury-time-blue" class="mini-time" type="button">TIB 0:00</button>
        </div>
        <div id="event-buttons-blue" class="event-grid" aria-label="Blue Event Buttons">
            <button class="event-btn" type="button">[5B]</button>
            <button class="event-btn" type="button">[4B]</button>
            <button class="event-btn" type="button">[1B]</button>
            <button class="event-btn" type="button">[0B]</button>
            <button class="event-btn" type="button">[PB]</button>
            <button class="event-btn" type="button">[2B]</button>
        </div>
      </article>
    </section>
  </main>

  <div style="position: fixed; top: 0; left: 0; opacity: 0; width: 10px; height: 10px;">
    <button id="start" type="button">Start</button>
    <button id="stop" type="button">Stop</button>
  </div>

  <script>
    // ===================================================================
    // APP STATE
    // ===================================================================
    const appState = {
      mode: 'Idle', // 'Idle' | 'Recording'
      timerRunning: false,
      timerIntervalId: null,
      boutTime100ms: 0, // in 100ms units
      periodTime100ms: 1800, // 3 minutes = 180 seconds = 1800 * 100ms units
      sequenceCounter: 0,
      events: [],
      createdAt: null,
      completed: false,
      completedAt: null,
      victoryType: null,
      classificationPoints: null,
      keyBuffer: []
    };

    // ===================================================================
    // TIMER LOGIC
    // ===================================================================
    const boutTimeDisplay = document.getElementById("bout-time-display");
    const startButton = document.getElementById("start");
    const stopButton = document.getElementById("stop");
    const boutTimeButton = document.getElementById("bout-time-button");

    // Test-only functions that bypass mode checks
    function testStartTimer() {
      if (appState.timerIntervalId !== null) return;
      appState.timerRunning = true;
      appState.timerIntervalId = setInterval(tick, 100);
    }

    function testStopTimer() {
      if (appState.timerIntervalId === null) return;
      clearInterval(appState.timerIntervalId);
      appState.timerIntervalId = null;
      appState.timerRunning = false;
    }

    function formatTime100ms(time100ms) {
      const totalSeconds = Math.floor(time100ms / 10);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const fraction = Math.floor((time100ms % 10));
      return `${minutes}:${seconds.toString().padStart(2, "0")}.${fraction}`;
    }

    function formatTimeSeconds(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${minutes}:${secs.toString().padStart(2, "0")}`;
    }

    function updateBoutTimeDisplay() {
      boutTimeDisplay.textContent = formatTimeSeconds(Math.floor(appState.periodTime100ms / 10));
    }

    function tick() {
      if (!appState.timerRunning) return;
      
      appState.boutTime100ms++;
      appState.periodTime100ms--;
      
      updateBoutTimeDisplay();
      
      if (appState.periodTime100ms <= 0) {
        stopTimer();
        if (appState.mode === 'Recording') {
          recordEvent({ eventType: 'PeriodEnd', boutTime100ms: appState.boutTime100ms });
        }
      }
    }

    function startTimer() {
      if (appState.mode !== 'Recording') return;
      if (appState.timerIntervalId !== null) return;
      
      appState.timerRunning = true;
      appState.timerIntervalId = setInterval(tick, 100); // 100ms intervals
      recordEvent({ eventType: 'T_Started', boutTime100ms: appState.boutTime100ms });
    }

    function stopTimer() {
      if (appState.timerIntervalId === null) return;
      
      clearInterval(appState.timerIntervalId);
      appState.timerIntervalId = null;
      appState.timerRunning = false;
      
      recordEvent({ eventType: 'T_Stopped', boutTime100ms: appState.boutTime100ms });
    }

    function toggleTimer() {
      if (appState.mode !== 'Recording') return;
      
      if (appState.timerRunning) {
        stopTimer();
      } else {
        startTimer();
      }
    }

    startButton.addEventListener("click", testStartTimer);
    stopButton.addEventListener("click", testStopTimer);
    boutTimeButton.addEventListener("click", toggleTimer);
    updateBoutTimeDisplay();

    // ===================================================================
    // EVENT RECORDING
    // ===================================================================
    function recordEvent(eventData) {
      appState.sequenceCounter++;
      const event = {
        seq: appState.sequenceCounter,
        timestamp: new Date().toISOString(),
        ...eventData
      };
      appState.events.push(event);
      
      // Update UI after recording event
      updateScores();
      updateTimeline();
      
      console.log('Event recorded:', event);
      return event;
    }

    // ===================================================================
    // STATE MANAGEMENT
    // ===================================================================
    const releaseCompleteButton = document.getElementById('release-complete-button');
    const boutInfoField = document.getElementById('bout-info');
    const styleSelect = document.getElementById('style-select');
    const rulesetSelect = document.getElementById('ruleset-select');
    const timeline = document.getElementById('timeline');

    function releaseScoresheet() {
      if (appState.mode !== 'Idle') return;
      
      appState.mode = 'Recording';
      appState.createdAt = new Date().toISOString();
      
      recordEvent({ eventType: 'ScoresheetReleased' });
      
      // Lock input fields
      boutInfoField.disabled = true;
      styleSelect.disabled = true;
      rulesetSelect.disabled = true;
      
      // Update button
      releaseCompleteButton.textContent = 'Abschließen [F4]';
      
      // Clear timeline and show next-event
      updateTimeline();
      
      console.log('Scoresheet released for recording');
    }

    function completeScoresheet(victoryType, classificationPoints) {
      if (appState.mode !== 'Recording') return;
      
      appState.mode = 'Idle';
      appState.completed = true;
      appState.completedAt = new Date().toISOString();
      appState.victoryType = victoryType;
      appState.classificationPoints = classificationPoints;
      
      // Stop timer if running
      if (appState.timerRunning) {
        stopTimer();
      }
      
      recordEvent({ 
        eventType: 'ScoresheetCompleted',
        victoryType: victoryType,
        classificationPoints: classificationPoints
      });
      
      // Update button
      releaseCompleteButton.textContent = 'Freigeben [F4]';
      
      console.log('Scoresheet completed:', victoryType, classificationPoints);
    }

    function showCompletionDialog() {
      const scores = calculateScores(appState.events);
      const winner = scores.red > scores.blue ? 'red' : (scores.blue > scores.red ? 'blue' : 'draw');
      
      // Simple completion for now - in a real app, this would be a proper modal
      const victoryType = prompt('Siegart (SS, TÜ, PS, etc.):') || 'SS';
      const winnerPoints = parseInt(prompt('Klassifizierungspunkte Sieger:') || '4');
      const loserPoints = parseInt(prompt('Klassifizierungspunkte Verlierer:') || '0');
      
      if (victoryType) {
        completeScoresheet(victoryType, [winnerPoints, loserPoints]);
      }
    }

    releaseCompleteButton.addEventListener('click', () => {
      if (appState.mode === 'Idle') {
        releaseScoresheet();
      } else if (appState.mode === 'Recording') {
        showCompletionDialog();
      }
    });

    // ===================================================================
    // SCORE CALCULATION
    // ===================================================================
    const scoreRedDisplay = document.getElementById('score-red');
    const scoreBlueDisplay = document.getElementById('score-blue');

    function calculateScores(events) {
      const scores = { red: 0, blue: 0 };
      
      events.forEach(e => {
        // Technical points: 1R, 2R, 4R, 5R, 1B, 2B, 4B, 5B
        const pointMatch = e.eventType.match(/^([1245])(R|B)$/);
        if (pointMatch) {
          const points = parseInt(pointMatch[1]);
          const side = pointMatch[2] === 'R' ? 'red' : 'blue';
          scores[side] += points;
        }
        
        // Cautions award points to opponent: 0R1B, 0R2B, 0B1R, 0B2R
        const cautionMatch = e.eventType.match(/^0([RB])([12])([RB])$/);
        if (cautionMatch) {
          const points = parseInt(cautionMatch[2]);
          const recipient = cautionMatch[3] === 'R' ? 'red' : 'blue';
          scores[recipient] += points;
        }
      });
      
      return scores;
    }

    function updateScores() {
      const scores = calculateScores(appState.events);
      scoreRedDisplay.textContent = scores.red;
      scoreBlueDisplay.textContent = scores.blue;
    }

    // ===================================================================
    // TIMELINE RENDERING
    // ===================================================================
    function updateTimeline() {
      timeline.innerHTML = '';
      
      // Filter to only bout events with bout time
      const boutEvents = appState.events.filter(e => 
        e.boutTime100ms !== undefined && 
        !e.eventType.startsWith('T_') &&
        e.eventType !== 'ScoresheetReleased' &&
        e.eventType !== 'ScoresheetCompleted'
      );
      
      boutEvents.forEach(event => {
        const entry = createTimelineEntry(event);
        timeline.appendChild(entry);
      });
      
      // Add next-event entry if in Recording mode
      if (appState.mode === 'Recording') {
        const nextEventEntry = document.createElement('div');
        nextEventEntry.id = 'next-event';
        nextEventEntry.className = 'entry';
        nextEventEntry.innerHTML = `
          <div class="entry-box next cursor">+</div>
          <div class="entry-time">Next</div>
        `;
        timeline.appendChild(nextEventEntry);
      }
    }

    function createTimelineEntry(event) {
      const entry = document.createElement('div');
      entry.className = 'entry';
      
      const eventType = event.eventType;
      let boxHtml = '';
      
      // Check if it's a caution event (0R1B, 0R2B, 0B1R, 0B2R)
      const cautionMatch = eventType.match(/^0([RB])([12])([RB])$/);
      if (cautionMatch) {
        const cautionSide = cautionMatch[1] === 'R' ? 'red' : 'blue';
        const pointSide = cautionMatch[3] === 'R' ? 'red' : 'blue';
        boxHtml = `
          <div class="entry-box caution ${cautionSide === 'red' ? 'red' : 'blue'}">
            <div class="caution-row ${cautionSide}">${cautionMatch[1]}0</div>
            <div class="caution-row ${pointSide}">${cautionMatch[2]}${cautionMatch[3]}</div>
          </div>
        `;
      } else {
        // Regular event (points or passivity)
        const colorClass = eventType.includes('R') ? 'red' : (eventType.includes('B') ? 'blue' : 'next');
        boxHtml = `<div class="entry-box ${colorClass}">${eventType}</div>`;
      }
      
      entry.innerHTML = `
        ${boxHtml}
        <div class="entry-time">${formatTime100ms(event.boutTime100ms)}</div>
      `;
      
      return entry;
    }

    // ===================================================================
    // KEYBOARD INPUT HANDLER
    // ===================================================================
    function processKeySequence(buffer) {
      const seq = buffer.join('').toUpperCase();
      
      // Only process bout events in Recording mode
      if (appState.mode !== 'Recording') return false;
      
      // Space: Toggle timer
      if (seq === ' ') {
        toggleTimer();
        return true;
      }
      
      // Technical points: R1, 1R, R2, 2R, R4, 4R, R5, 5R, B1, 1B, B2, 2B, B4, 4B, B5, 5B
      if (seq.match(/^[RB][1245]$/)) {
        const points = seq[1];
        const side = seq[0];
        recordEvent({ eventType: `${points}${side}`, boutTime100ms: appState.boutTime100ms });
        return true;
      }
      if (seq.match(/^[1245][RB]$/)) {
        const points = seq[0];
        const side = seq[1];
        recordEvent({ eventType: `${points}${side}`, boutTime100ms: appState.boutTime100ms });
        return true;
      }
      
      // Passivity: RP, PR, BP, PB
      if (seq === 'RP' || seq === 'PR') {
        recordEvent({ eventType: 'PR', boutTime100ms: appState.boutTime100ms });
        return true;
      }
      if (seq === 'BP' || seq === 'PB') {
        recordEvent({ eventType: 'PB', boutTime100ms: appState.boutTime100ms });
        return true;
      }
      
      // Cautions: R01, 0R1, R02, 0R2, B01, 0B1, B02, 0B2
      if (seq.match(/^[RB]0[12]$/)) {
        const cautionSide = seq[0];
        const points = seq[2];
        const pointSide = cautionSide === 'R' ? 'B' : 'R';
        recordEvent({ eventType: `0${cautionSide}${points}${pointSide}`, boutTime100ms: appState.boutTime100ms });
        return true;
      }
      if (seq.match(/^0[RB][12]$/)) {
        const cautionSide = seq[1];
        const points = seq[2];
        const pointSide = cautionSide === 'R' ? 'B' : 'R';
        recordEvent({ eventType: `0${cautionSide}${points}${pointSide}`, boutTime100ms: appState.boutTime100ms });
        return true;
      }
      
      return false;
    }

    function isValidContinuation(buffer, key) {
      const seq = buffer.join('').toUpperCase();
      const newKey = key.toUpperCase();
      
      // Empty buffer - accept most keys
      if (buffer.length === 0) {
        return ['R', 'B', 'P', '1', '2', '4', '5', '0', ' '].includes(newKey);
      }
      
      // Single key sequences
      if (buffer.length === 1) {
        if (seq === 'R') return ['1', '2', '4', '5', 'P', '0'].includes(newKey);
        if (seq === 'B') return ['1', '2', '4', '5', 'P', '0'].includes(newKey);
        if (seq === 'P') return ['R', 'B'].includes(newKey);
        if (['1', '2', '4', '5'].includes(seq)) return ['R', 'B'].includes(newKey);
        if (seq === '0') return ['R', 'B'].includes(newKey);
      }
      
      // Two key sequences
      if (buffer.length === 2) {
        if (seq === 'R0') return ['1', '2'].includes(newKey);
        if (seq === 'B0') return ['1', '2'].includes(newKey);
        if (seq === '0R') return ['1', '2'].includes(newKey);
        if (seq === '0B') return ['1', '2'].includes(newKey);
      }
      
      return false;
    }

    document.addEventListener('keydown', (e) => {
      const key = e.key;
      
      // Handle function keys directly (F4, F8)
      if (key === 'F4') {
        if (appState.mode === 'Idle') {
          releaseScoresheet();
        } else if (appState.mode === 'Recording') {
          showCompletionDialog();
        }
        e.preventDefault();
        return;
      }
      
      if (key === 'F8' && appState.completed) {
        downloadExport();
        e.preventDefault();
        return;
      }
      
      // Escape clears buffer
      if (key === 'Escape') {
        appState.keyBuffer = [];
        console.log('Key buffer cleared');
        return;
      }
      
      // Check if key is valid continuation
      if (!isValidContinuation(appState.keyBuffer, key)) {
        // Invalid key - ignore
        console.log('Invalid key for current buffer:', key);
        return;
      }
      
      // Add to buffer
      appState.keyBuffer.push(key);
      console.log('Key buffer:', appState.keyBuffer);
      
      // Try to process sequence
      if (processKeySequence(appState.keyBuffer)) {
        // Sequence processed - clear buffer
        appState.keyBuffer = [];
        console.log('Sequence processed, buffer cleared');
      }
    });

    // --- Ruleset helper -------------------------------------------------
    function loadEmbeddedRuleset() {
      const el = document.getElementById('default-ruleset');
      if (!el) return null;
      try {
        return JSON.parse(el.textContent);
      } catch (e) {
        console.error('Failed to parse embedded ruleset:', e);
        return null;
      }
    }

    function simpleValidateRuleset(r) {
      const errors = [];
      if (!r) { errors.push('ruleset missing'); return { valid: false, errors }; }
      if (!r.metadata || typeof r.metadata.name !== 'string') errors.push('metadata.name required');
      if (!Array.isArray(r.periodTimesInSeconds)) errors.push('periodTimesInSeconds array required');
      if (typeof r.periodTimeCountingDirection !== 'string') errors.push('periodTimeCountingDirection required');
      if (typeof r.periodBreakTimeInSeconds !== 'number') errors.push('periodBreakTimeInSeconds required');
      if (!Array.isArray(r.victoryTypes)) errors.push('victoryTypes array required');
      if (Array.isArray(r.victoryTypes)) {
        r.victoryTypes.forEach((vt, i) => {
          if (typeof vt.type !== 'string') errors.push(`victoryTypes[${i}].type required`);
          if (!Array.isArray(vt.classificationPoints) || vt.classificationPoints.length !== 2) errors.push(`victoryTypes[${i}].classificationPoints must be [win,lose]`);
          if (vt.condition && typeof vt.condition === 'object') {
            Object.values(vt.condition).forEach(op => {
              if (typeof op !== 'object') errors.push(`victoryTypes[${i}].condition entries must be objects`);
            });
          }
        });
      }
      return { valid: errors.length === 0, errors };
    }

    function evalOperator(value, op, target) {
      if (op.gte !== undefined && !(value >= op.gte)) return false;
      if (op.lte !== undefined && !(value <= op.lte)) return false;
      if (op.gt !== undefined && !(value > op.gt)) return false;
      if (op.lt !== undefined && !(value < op.lt)) return false;
      if (op.eq !== undefined && !(value === op.eq)) return false;
      return true;
    }

    function evaluateCondition(condition, context) {
      if (!condition) return true;
      // All named condition fields must be satisfied (AND)
      for (const key in condition) {
        const op = condition[key];
        const value = context[key];
        if (value === undefined) return false;
        if (!evalOperator(value, op, key)) return false;
      }
      return true;
    }

    function findMatchingVictoryTypes(ruleset, context) {
      if (!ruleset || !Array.isArray(ruleset.victoryTypes)) return [];
      return ruleset.victoryTypes.filter(vt => {
        if (!vt.condition) return true;
        return evaluateCondition(vt.condition, context);
      });
    }

    // Expose helper
    window.rulesetHelper = {
      load: loadEmbeddedRuleset,
      validate: simpleValidateRuleset,
      evaluateCondition,
      findMatchingVictoryTypes
    };

    // Auto-load and validate at startup (logs result)
    const _embeddedRuleset = loadEmbeddedRuleset();
    const _valid = simpleValidateRuleset(_embeddedRuleset);
    if (!_valid.valid) console.warn('Embedded ruleset validation warnings:', _valid.errors);

    // --- Export functionality --------------------------------------------
    function getSystemMetadata() {
      return {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        languages: Array.from(navigator.languages || [navigator.language]),
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        timestamp: new Date().toISOString(),
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timezoneOffset: new Date().getTimezoneOffset()
      };
    }

    function parseInfo(infoString) {
      // Parse key-value pairs from info string (spec: key:value; separator)
      const pairs = {};
      const segments = infoString.split(';').map(s => s.trim());
      let anonCounter = 1;
      
      segments.forEach(seg => {
        if (!seg) return;
        const colonIdx = seg.indexOf(':');
        if (colonIdx === -1) {
          pairs[`$anonym${anonCounter++}`] = seg;
        } else {
          let key = seg.substring(0, colonIdx).trim();
          const value = seg.substring(colonIdx + 1).trim();
          
          if (key.startsWith('$$')) {
            // Hidden pair - don't include in parsedInfo
            return;
          }
          if (key.startsWith('$')) {
            pairs[`anonym${anonCounter++}`] = value;
          } else {
            pairs[key.toLowerCase()] = value;
          }
        }
      });
      return pairs;
    }

    function calculateStatistics(events) {
      const stats = {
        red: {
          technicalPoints: { "1": 0, "2": 0, "4": 0, "5": 0 },
          passivity: 0,
          cautions: 0,
          injuryTime100ms: 0,
          bloodTime100ms: 0
        },
        blue: {
          technicalPoints: { "1": 0, "2": 0, "4": 0, "5": 0 },
          passivity: 0,
          cautions: 0,
          injuryTime100ms: 0,
          bloodTime100ms: 0
        },
        totalEvents: events.length,
        corrections: 0
      };

      events.forEach(e => {
        // Technical points
        const pointMatch = e.eventType.match(/^([1245])(R|B)$/);
        if (pointMatch) {
          const points = pointMatch[1];
          const side = pointMatch[2] === 'R' ? 'red' : 'blue';
          stats[side].technicalPoints[points]++;
        }
        
        // Passivity
        if (e.eventType === 'PR') stats.red.passivity++;
        if (e.eventType === 'PB') stats.blue.passivity++;
        
        // Cautions
        if (e.eventType.match(/^0R[12]B$/)) stats.red.cautions++;
        if (e.eventType.match(/^0B[12]R$/)) stats.blue.cautions++;
        
        // Corrections
        if (e.eventType.startsWith('Event') || e.eventType.includes('_Modified')) {
          stats.corrections++;
        }
      });

      return stats;
    }

    function calculateScores(events) {
      const scores = { red: 0, blue: 0 };
      
      events.forEach(e => {
        const pointMatch = e.eventType.match(/^([1245])(R|B)$/);
        if (pointMatch) {
          const points = parseInt(pointMatch[1]);
          const side = pointMatch[2] === 'R' ? 'red' : 'blue';
          scores[side] += points;
        }
        
        // Cautions award points to opponent
        const cautionMatch = e.eventType.match(/^0([RB])([12])([RB])$/);
        if (cautionMatch) {
          const points = parseInt(cautionMatch[2]);
          const recipient = cautionMatch[3] === 'R' ? 'red' : 'blue';
          scores[recipient] += points;
        }
      });
      
      return scores;
    }

    function generateExport() {
      const ruleset = loadEmbeddedRuleset();
      const boutInfo = document.getElementById('bout-info')?.value || '';
      const style = document.getElementById('style-select')?.value || 'Freestyle';
      const rulesetName = document.getElementById('ruleset-select')?.value || 'Default Ruleset';
      const redInfo = document.getElementById('info-red')?.textContent || 'Rot';
      const blueInfo = document.getElementById('info-blue')?.textContent || 'Blau';
      
      const scores = calculateScores(appState.events);
      const statistics = calculateStatistics(appState.events);
      
      // Calculate winner
      let winner = 'none';
      if (appState.completed && scores.red > scores.blue) winner = 'red';
      else if (appState.completed && scores.blue > scores.red) winner = 'blue';
      else if (appState.completed && scores.red === scores.blue) winner = 'draw';
      
      // Calculate total bout time (sum of running periods)
      let totalBoutTime100ms = 0;
      let timerStartTime = 0;
      appState.events.forEach(e => {
        if (e.eventType === 'T_Started') {
          timerStartTime = e.boutTime100ms;
        } else if (e.eventType === 'T_Stopped' && timerStartTime !== null) {
          totalBoutTime100ms += (e.boutTime100ms - timerStartTime);
          timerStartTime = null;
        }
      });
      
      // Calculate real time duration
      let totalRealTime = 0;
      if (appState.createdAt && appState.completedAt) {
        totalRealTime = new Date(appState.completedAt) - new Date(appState.createdAt);
      }
      
      // Filter timeline (only bout events)
      const timeline = appState.events.filter(e => 
        e.boutTime100ms !== undefined && 
        !e.eventType.startsWith('T_') &&
        !e.eventType.startsWith('Event') &&
        !e.eventType.includes('_Modified') &&
        e.eventType !== 'ScoresheetReleased' &&
        e.eventType !== 'ScoresheetCompleted'
      ).map(e => ({
        seq: e.seq,
        eventType: e.eventType,
        boutTime100ms: e.boutTime100ms
      }));

      const exportData = {
        "$schema": "./export-v1.schema.json",
        "exportVersion": "1.0",
        "metadata": {
          "app": {
            "name": "CHAMP Protocol",
            "version": "1.0.0",
            "build": "2025-01-15T10:30:00Z"
          },
          "system": getSystemMetadata()
        },
        "bout": {
          "header": {
            "createdAt": appState.createdAt || new Date().toISOString(),
            "info": boutInfo,
            "style": style,
            "ruleset": {
              "reference": ruleset?.metadata?.name || rulesetName,
              "embedded": ruleset
            },
            "wrestlers": {
              "red": {
                "info": redInfo,
                "parsedInfo": parseInfo(redInfo)
              },
              "blue": {
                "info": blueInfo,
                "parsedInfo": parseInfo(blueInfo)
              }
            }
          },
          "summary": {
            "completed": appState.completed,
            "completedAt": appState.completedAt,
            "duration": {
              "totalBoutTime100ms": totalBoutTime100ms,
              "totalRealTime": totalRealTime,
              "periods": []
            },
            "scores": scores,
            "winner": winner,
            "victory": appState.victoryType ? {
              "type": appState.victoryType,
              "description": "",
              "classificationPoints": appState.classificationPoints || [0, 0]
            } : undefined,
            "statistics": statistics,
            "timeline": timeline,
            "notes": ""
          },
          "events": appState.events
        }
      };

      return exportData;
    }

    function downloadExport() {
      const exportData = generateExport();
      const jsonString = JSON.stringify(exportData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
      const filename = `champ-export-${timestamp}.json`;
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('Export downloaded:', filename);
    }

    // Expose export helper
    window.exportHelper = {
      generate: generateExport,
      download: downloadExport
    };

    // ===================================================================
    // INITIALIZATION
    // ===================================================================
    function initializeApp() {
      // Clear timeline for Idle state
      timeline.innerHTML = '';
      
      // Initialize scores
      updateScores();
      
      // Set initial button state
      releaseCompleteButton.textContent = 'Freigeben [F4]';
      
      // Ensure input fields are enabled in Idle state
      boutInfoField.disabled = false;
      styleSelect.disabled = false;
      rulesetSelect.disabled = false;
      
      console.log('App initialized in Idle state');
    }

    // Initialize on page load
    initializeApp();
  </script>

  <!-- Embedded default ruleset: protocol/rulesets/ruleset-default.json -->
  <script id="default-ruleset" type="application/json">
  {
    "metadata": {
      "name": "de-mannschaftskampf-2025",
      "description": "Deutsches Regelwerk für Mannschaftskämpfe",
      "languages": ["de"],
      "author": "Deutscher Ringer-Bund"
    },
    "periodTimesInSeconds": [180, 180],
    "periodTimeCountingDirection": "Down",
    "periodBreakTimeInSeconds": 30,
    "injuryTimeWithoutBloodInSeconds": 120,
    "injuryTimeWithBloodInSeconds": 240,
    "injuryTimeCountingDirection": "Up",
    "freestyle": {
      "activityTimeInSeconds": 30,
      "activityTimeCountingDirection": "Down",
      "activityTimeCondition": {
        "passivityCount": { "gt": 1 }
      }
    },
    "victoryTypes": [
      { "type": "SS", "description": "Schultersieg", "classificationPoints": [4, 0] },
      {
        "type": "TÜ",
        "description": "Technische Überlegenheit",
        "classificationPoints": [4, 0],
        "condition": { "scoreDifference": { "gte": 15 } }
      },
      {
        "type": "PS",
        "description": "Punktsieg",
        "classificationPoints": [3, 0],
        "condition": { "scoreDifference": { "gte": 8, "lte": 14 } }
      },
      {
        "type": "PS",
        "description": "Punktsieg",
        "classificationPoints": [2, 0],
        "condition": { "scoreDifference": { "gte": 3, "lte": 7 } }
      },
      {
        "type": "PS",
        "description": "Punktsieg",
        "classificationPoints": [1, 0],
        "condition": { "scoreDifference": { "gte": 0, "lte": 2 } }
      },
      { "type": "AS", "description": "Aufgabesieg", "classificationPoints": [4, 0] },
      { "type": "DV", "description": "Disqualifikation durch 3 Verwarnungen", "classificationPoints": [4, 0], "condition": { "cautionCount": { "gte": 3 } } },
      { "type": "DQ", "description": "Disqualifikation durch unfaires Verhalten", "classificationPoints": [4, 0] },
      { "type": "DSQ2", "description": "Beide Ringer disqualifiziert wegen unfairem Verhalten", "classificationPoints": [0, 0] },
      { "type": "KL", "description": "Kampfloser Sieg", "classificationPoints": [4, 0] },
      { "type": "ÜG", "description": "Übergewicht", "classificationPoints": [4, 0] }
    ]
  }
  </script>
</body>
</html>